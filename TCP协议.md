##TCP协议

###1、建立连接3次交互

  
			   | 1                       | 2                                     | 3           
------------ | ----------------------- | ------------------------------------- | ----------------------------   
client       | SYN=1,seq=X SYN_SEND    | ——                                    | ACK=1,ACKnum=y+1 ESTABLISHED
server       | ——                      | SYN=1,ACK=1,seq=y,ACKnum=X+1 SYN_RCVD |                  ESTABLISHED


 + 第一次握手(SYN=1,seq=X)
   
   客户端发送一个TCP的SYN=1的包，指明客户端要连接服务器的端口，以及初始化序列号X
   
   发送完毕后，进入```SYN_SEND```状态
  
 + 第二次握手(SYN=1,ACK=1,seq=y,ACKnum=X+1)
 
 	服务端发回ACK确认包，SYN=1和ACK=1，seq为服务器自己的序列号y，ACKnum=X+1
 	
 	发送完毕后，进入```SYN_RCVD```状态
 	
 + 第三次握手(ACK=1,ACKnum=y+1)

 	发送完毕后进入```ESTABLISHED```状态
 	
 	服务器收到后进入```ESTABLISHED```状态
 	
###为什么需要三次握手

 + 在第一次通信过程中，A向B发送信息之后，B收到信息后可以确认自己的收信能力和A的发信能力没有问题。
 + 在第二次通信中，B向A发送信息之后，A可以确认自己的发信能力和B的收信能力没有问题，但是B不知道自己的发信能力到底如何，所以就需要第三次通信。
 + 在第三次通信中，A向B发送信息之后，B就可以确认自己的发信能力没有问题。 
 	
###2、断开连接4次交互

			   | 1                       | 2                           | 3                            | 4
------------ | ----------------------- | --------------------------- | ---------------------------- | -------------------------- 
client       | FIN=1,seq=x FIN_WAIT_1  | ——               FIN_WAIT_2 | ——                           | ACK=1,ACKnum=y+1 TIME_WAIT...CLOSED
server       | ——                      | ACK=1,ACKnum=x+1 CLOSE_WAIT | FIN=1,seq=y LAST_ACK         |                  CLOSED

 + 第一次挥手(FIN=1,seq=x)
 
 	客户端发送一个FIN=1的包，表示没有可用数据可发送，但仍可用接受数据
 	
 	发送完成后，客户端进入```FIN_WAIT_1```状态
 	
 + 第二次挥手(ACK=1,ACKnum=x+1)
 
 	服务端收到FIN包后，发送ACK=1,ACKnum=x+1确认包，表示收到了客户端关闭连接的请求，但还没有准备好关闭连接
 	
 	发送完毕后，服务端进入```CLOSE_WAIT```状态，客户端收到这个确认包后，进入```FIN_WAIT_2```状态，等待服务端关闭连接
 	
 + 第三次挥手(FIN=1,seq=y)
 
 	服务端准备好关闭连接，发送结束连接请求，FIN=1
 	
 	发送完毕后，服务端进入```LAST_ACK```状态，等待客户端最后一个ACK
 
 + 第四次挥手(ACK=1,ACKnum=y+1)
 
 	客户端收到来自服务器的关闭连接请求，发送一个确认包，进入```TIME_WAIT```状态，等待可能出现的要求重传的ACK包
 	
 	服务端收到这个确认包后，关闭连接，进入```CLOSED```状态
 	
 	客户端等待一段时间后，没有得到回复，确认服务端断开连接，客户端进入```CLOSED```状态
 	
 ###TCP重传机制
  
 + 超时重传机制
  
  	- 只重传丢失的包
  
  	- 重传丢失包后的所有包
  	
  	1、节省带宽，但是慢。
  	
  	2、会快一点，但是浪费带宽
  	
  	因为要等timeout，可能时间会很长。

 + 快速重传机制(Fast Retransmit算法)

 	- 不以时间驱动重传，而已数据驱动重传。如果包没有连续到达，则ack可能丢失了的包，连续ack3次后，发送端重传
 
